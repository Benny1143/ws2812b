module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output outled,           // to LED strip, Br pin C49, connect LED Strip to 5V for power
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  // We shall always assume that COLUMN_DIMENSION and ROW_DIMENSION is a 2^x
  const COLUMN_DIMENSION = 16; // how many "columns"? 
  const ROW_DIMENSION = 4; // how many "rows"?

  const PIXEL_COUNT = COLUMN_DIMENSION *  ROW_DIMENSION;   
  const ENCODING_AMOUNT = 4; // how many different encodings are used? As example, we use 4
  
  // WHITE (11), BLUE (10), RED (01), GREEN (00)
  const LEDCOLOR = {24hFFFFFF, 24hFF0000, 24h00FF00, 24h0000FF}; 
  
  sig rst; // reset signal

  // the data_ram
  data_ram ram(.clk(clk), .rst(rst));
  
  ws2812b_writer led_strip(#PIXEL_COUNT(PIXEL_COUNT), .clk(clk), .rst(rst)); 
  fsm state(.clk(clk), .rst(rst)) = {IDLE, LOAD};
  
  reverser index_reverser(.clk(clk), .rst(rst), #COLUMN_DIMENSION(COLUMN_DIMENSION), #ROW_DIMENSION(ROW_DIMENSION));
  
  // user inputs 
  button_conditioner latch_button(.clk(clk));
  edge_detector latch_button_edge(.clk(clk), #RISE(1), #FALL(0));
  button_conditioner clear_button(.clk(clk));
  edge_detector clear_button_edge(.clk(clk), #RISE(1), #FALL(0));
  button_conditioner reverse_button(.clk(clk));
  edge_detector reverse_button_edge(.clk(clk), #RISE(1), #FALL(0));
  
  // a state to toggle revere 
  dff matrix_used(#INIT(0), .clk(clk), .rst(rst));
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    ram.address = 0;        // address 0 selected by default
    
    latch_button.in = io_button[0]; // use this button to latch io_dip value to led_encoding dff 
    latch_button_edge.in = latch_button.out;
    
    clear_button.in = io_button[2]; // use this button to turn off all LEDs 
    clear_button_edge.in = clear_button.out;
    
    reverse_button.in = io_button[1]; // use this button to enable reverse
    reverse_button_edge.in = reverse_button.out;
    
    // toggle matrix used button 
    if (reverse_button_edge.out){
      matrix_used.d = matrix_used.q + 1;
    }
    
    led_strip.update = 0; // do not refresh by default
    led_strip.clear = 0; // do not clear by default
    
    // connect reverser to led_strip 
    index_reverser.original_pixel_address = led_strip.pixel_address;
    index_reverser.writer_pixel_done = led_strip.next_pixel;
    index_reverser.activate = matrix_used.q;
    
    ram.address = 0; 

    // use io_dip[2:0]  to encode 12 unique pixel values at most (24 bits)
    case (state.q){
      state.IDLE:
             // when ram is ready, and led is idling at RESET state, we load the strip
             if (latch_button_edge.out & ram.ready & led_strip.reset){
                state.d = state.LOAD;
                ram.address = index_reverser.effective_pixel_address;
                led_strip.update = 1;
              }
             if (clear_button_edge.out){
                 led_strip.clear = 1;
              }
      
      state.LOAD:
            // if at the last FPGA clock cycle for this bit, advance the address first because our RAM needs 1 additional clock cycle to work
            if (led_strip.next_pixel){
              index_reverser.original_pixel_address = led_strip.pixel_address + 1;
            }
      
            // pass this to ram 
            ram.address = index_reverser.effective_pixel_address;
            
            // wait until we are all done in updating our LED;
            if (led_strip.done){
                state.d = state.IDLE;
            }
    }

    led_strip.color = LEDCOLOR[ram.out_encoding]; 
    outled = led_strip.led;
    
    // debug 
    io_led[0] = index_reverser.effective_pixel_address;
    io_led[1] = led_strip.pixel_address;
    io_led[2] = ram.debug_rom_data;
    
    // show the current LED color
    led[0] = matrix_used.q; 
    led[7:1] = led_strip.pixel_address;
    

    
  }
}