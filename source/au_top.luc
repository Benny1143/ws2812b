module au_top (
    input clk,              // 100MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input usb_rx,           // USB->Serial input
    output outled,           // to LED strip, Br pin C49, connect LED Strip to 5V for power
    output usb_tx,          // USB->Serial output
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8]     // DIP switches on IO Shield
  ) {
  
  const PIXEL_COUNT = 12;   // light up 12 LEDs in the strip
  const ENCODING_AMOUNT = 4; // how many different encodings are used?
  sig rst;                  // reset signal
  sig transformed_pixel_address[$clog2(PIXEL_COUNT*2)];
  sig current_color_encoding[$clog2(ENCODING_AMOUNT)];
  var index;

  
  // WHITE (11), BLUE (10), RED (01), GREEN (00)
  const LEDCOLOR = {24hFFFFFF, 24hFF0000, 24h00FF00, 24h0000FF}; 
  
  // (connector) WHITE WHITE BLUE WHITE RED WHITE GREEN WHITE WHITE BLUE BLUE BLUE (end of strip)
  // e.g: E is 1110 ---> 10 first (BLUE) then 11 (WHITE)
  dff led_encoding[PIXEL_COUNT*2](.clk(clk), .rst(rst), #INIT(24hABCDEF)); // 2 bit to encode a color 
  dff temp_encoding[PIXEL_COUNT*2](.clk(clk), .rst(rst), #INIT(0));
  ws2812b_writer led_strip(#PIXEL_COUNT(PIXEL_COUNT), .clk(clk), .rst(rst)); 
  fsm state(.clk(clk), .rst(rst)) = {IDLE, LOAD};
  
  button_conditioner user_button(.clk(clk));
  edge_detector user_button_edge(.clk(clk));
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
    reset_conditioner reset_cond;
  }
  
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    usb_tx = usb_rx;        // loop serial port
    
    led = 8h00;             // turn LEDs off
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    
    user_button.in = io_button[0]; // use this button to latch io_dip value to led_encoding dff 
    user_button_edge.in = user_button.out;
    
    // use io_dip[2:0]  to encode 12 pixel values at most (24 bits)
    case (state.q){
      state.IDLE:
             if (user_button_edge.out){
                temp_encoding.d = c{io_dip[2], io_dip[1], io_dip[0]};
                state.d = state.LOAD;
              }
      
      state.LOAD:
            // wait until we are at RESET  state
            if (led_strip.reset){
                // load the dff with new value 
                led_encoding.d = temp_encoding.q;
                state.d = state.IDLE;
            }
    }

    led_strip.update = 1; // always write
    
    // led_strip.pixel_address will vary between 0000 to 1100 
    // address 0 --> bit 1:0 
    // address 1 --> bit 3:2 
    // address 2 --> bit 5
    // address N --> bit N*2+1:N*2

    transformed_pixel_address = led_strip.pixel_address * 2;
    
    // need to manually handle the encoding bit one by one for now
    // TODO: use a for-loop to DUPLICATE
    for (index=0; index<$clog2(ENCODING_AMOUNT); index++){
       current_color_encoding[index] = led_encoding.q[transformed_pixel_address+index];
    }
    
    // current_color_encoding[0] = led_encoding.q[transformed_pixel_address];
    // current_color_encoding[1] = led_encoding.q[transformed_pixel_address+1];
    
    // based on the encoding extracted from dff led_encoding, we get the 24bit color value
    led_strip.color = LEDCOLOR[current_color_encoding] ; 
    outled=led_strip.led;
    
    // debug 
    // show the current LED color
    io_led = $build(LEDCOLOR[current_color_encoding],3);
    

    
  }
}