module data_ram #(
    ROW_DIMENSION = 4 : ROW_DIMENSION > 0,
    COLUMN_DIMENSION = 4 : COLUMN_DIMENSION > 0,
    ENCODING_AMOUNT = 4 : ENCODING_AMOUNT > 0
    )(
    input clk,  // clock
    input rst,  // reset
    input update,
    input player_x_pos[3],
    input player_y_pos[3],
    input address[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    input playerMode,
    input playerColor[2],
    output out_encoding[2],
    output ready,
    output debug_address_pointer[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    output debug_data[3],
    output out_counter[$clog2(COLUMN_DIMENSION * ROW_DIMENSION)+1]
    //output out_holder[COLUMN_DIMENSION * ROW_DIMENSION*2]
  ) {
  
  const DEPTH =  COLUMN_DIMENSION * ROW_DIMENSION;
  fsm writer(.clk(clk), .rst(rst)) = {
    INIT, 
    WRITE,
    ERASE,
    IDLE
    };
  dff writer_pointer[$clog2(DEPTH)](#INIT(0),.clk(clk), .rst(rst));
  dff counter[$clog2(DEPTH)+1](#INIT(0),.clk(clk), .rst(rst));
  
  dff update_flag(#INIT(0), .clk(clk), .rst(rst));
  dff holder[COLUMN_DIMENSION][ROW_DIMENSION][2](.clk(clk), .rst(rst));

  dff playerMode_holder(#INIT(0), .clk(clk), .rst(rst));

  
  const BACKGROUND_COLOR = b00;
  //const PLAYER1_COLOR = b01;
  const PLAYER2_COLOR = b10;
  
  simple_dual_ram ram(.rclk(clk), .wclk(clk), #DEPTH(DEPTH), #SIZE($clog2(ENCODING_AMOUNT)));
  
  always {
    ram.raddr = 0;
    ram.waddr = 0;
    ram.write_data = 0;
    ram.write_en = 0;
    

    out_encoding = 0;
    debug_data = 0;
    
    ready = writer.q == writer.IDLE;
    debug_address_pointer = writer_pointer.q;
    
    // always catch any positive update request 
    if (update){
      update_flag.d = update;
    }
    // WHITE (11), DIM BLUE (10), DIM RED (01)
    case (writer.q){
      writer.INIT: 
        // set all values to zero 
        ram.write_en = b1; 
        ram.waddr = writer_pointer.q;
        // these are test dots, to know your hardware orientation
        // if (writer_pointer.q == d0){
        //   ram.write_data = PLAYER2_COLOR; // at RAM address 0, this will be your coordinate (0,0) write WHITE(11)
        // } else 
        ram.write_data = BACKGROUND_COLOR; 
        writer_pointer.d = writer_pointer.q + 1; 
        if (&writer_pointer.q){ // Unitl all 111111 exit
          ram.write_data = PLAYER2_COLOR; // Top right
          writer.d = writer.WRITE;
          writer_pointer.d = player_y_pos*8 + player_x_pos;
        }
        debug_data = b01;
        
      writer.ERASE:
        if(playerMode_holder.q == playerMode) {
          ram.write_en = b1; 
          ram.waddr = writer_pointer.q; // this is old player address
          ram.write_data = BACKGROUND_COLOR; // set back to background color
        } else {
          playerMode_holder.d = playerMode;
        }

        writer_pointer.d = player_y_pos*8 + player_x_pos; // update player position  
        writer.d = writer.WRITE;
     
      writer.WRITE:
        ram.write_en = b1;
        ram.waddr = writer_pointer.q;

        if(holder.q[player_x_pos][player_y_pos] == b00) {
          holder.d[player_x_pos][player_y_pos] = b01;
          counter.d = counter.q + 1;
        }
        
        ram.write_data = playerColor;
        writer.d = writer.IDLE; 
        
      writer.IDLE:
        ram.raddr = address;
        out_encoding = ram.read_data;
        debug_data = 0; // for debugging
        writer.d = writer.IDLE; // remain in state
        if (update_flag.q){
            update_flag.d = 0;
            writer.d = writer.ERASE;
        }
        debug_data = c{b11, update_flag.q};
    }
    
    out_counter = counter.q;
  }
}
