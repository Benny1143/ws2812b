module data_ram #(
    ROW_DIMENSION = 8 : ROW_DIMENSION > 0,
    COLUMN_DIMENSION = 8 : COLUMN_DIMENSION > 0,
    ENCODING_AMOUNT = 8 : ENCODING_AMOUNT > 0
    )(
    input clk,  // clock
    input rst,  // reset
    input update,
    input player_x_pos[3],
    input player_y_pos[3],
    input address[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    input playerMode,
    input playerColor[$clog2(ENCODING_AMOUNT)],
    output out_encoding[$clog2(ENCODING_AMOUNT)],
    output ready,
    output debug_address_pointer[$clog2(ROW_DIMENSION*COLUMN_DIMENSION)],
    output debug_data[3],
    output out_counter[$clog2(COLUMN_DIMENSION * ROW_DIMENSION)+1],
    output out_player1_score[$clog2(COLUMN_DIMENSION * ROW_DIMENSION)+1],
    output out_player2_score[$clog2(COLUMN_DIMENSION * ROW_DIMENSION)+1],
    output update_display
    //output out_holder[COLUMN_DIMENSION * ROW_DIMENSION*2]
  ) {
  
  const DEPTH =  COLUMN_DIMENSION * ROW_DIMENSION;
  fsm writer(.clk(clk), .rst(rst)) = {
    INIT, 
    WRITE,
    ERASE,
    UPDATE_SEG,
    INIT_BOMB,
    IDLE
    };
  dff writer_pointer[$clog2(DEPTH)](#INIT(0),.clk(clk), .rst(rst));
  dff counter[$clog2(DEPTH)+1](#INIT(0),.clk(clk), .rst(rst));

  dff player1_score[$clog2(DEPTH)+1](#INIT(0),.clk(clk), .rst(rst));
  dff player2_score[$clog2(DEPTH)+1](#INIT(0),.clk(clk), .rst(rst));
  
  dff update_flag(#INIT(0), .clk(clk), .rst(rst));
  dff holder[COLUMN_DIMENSION][ROW_DIMENSION][2](.clk(clk), .rst(rst));

  dff playerMode_holder(#INIT(0), .clk(clk), .rst(rst));

  dff random_generator[$clog2(DEPTH)](#INIT(0), .clk(clk), .rst(rst));
  dff bomb_set(#INIT(0), .clk(clk), .rst(rst));
  
  const BACKGROUND_COLOR = b00;
  //const PLAYER1_COLOR = b01;
  const PLAYER2_COLOR = b10;
  const BOMB_COLOR = b100;
  
  simple_dual_ram ram(.rclk(clk), .wclk(clk), #DEPTH(DEPTH), #SIZE($clog2(ENCODING_AMOUNT)));
  
  always {
    update_display = 0;
    ram.raddr = 0;
    ram.waddr = 0;
    ram.write_data = 0;
    ram.write_en = 0;

    out_encoding = 0;
    debug_data = 0;

    random_generator.d = random_generator.q + 1;
    
    ready = writer.q == writer.IDLE;
    debug_address_pointer = writer_pointer.q;
    
    // always catch any positive update request 
    if (update){
      update_flag.d = update;
    }
    // WHITE (11), DIM BLUE (10), DIM RED (01)
    case (writer.q){
      writer.INIT:
        // set all values to zero 
        ram.write_en = b1; 
        ram.waddr = writer_pointer.q;
        // these are test dots, to know your hardware orientation
        // if (writer_pointer.q == d0){
        //   ram.write_data = PLAYER2_COLOR; // at RAM address 0, this will be your coordinate (0,0) write WHITE(11)
        // } else 
        ram.write_data = b11; 
        writer_pointer.d = writer_pointer.q + 1; 
        if (&writer_pointer.q){ // Unitl all 111111 exit
          ram.write_data = PLAYER2_COLOR; // Top right
          writer.d = writer.WRITE;
          writer_pointer.d = player_y_pos*8 + player_x_pos;
        }
        debug_data = b01;
        
      writer.ERASE:
        if(playerMode_holder.q == playerMode) {
          ram.write_en = b1; 
          ram.waddr = writer_pointer.q; // this is old player address
          ram.write_data = BACKGROUND_COLOR; // set back to background color
        } else {
          playerMode_holder.d = playerMode;
        }

        writer_pointer.d = player_y_pos*8 + player_x_pos; // update player position  
        writer.d = writer.WRITE;
     
      writer.WRITE:
        ram.write_en = b1;
        ram.waddr = writer_pointer.q;
        ram.write_data = playerColor;
        writer.d = writer.IDLE;

        if(holder.q[player_x_pos][player_y_pos] == b00) {
          holder.d[player_x_pos][player_y_pos] = b01;
          counter.d = counter.q + 1;
          if(playerMode) {
            player1_score.d = player1_score.q + 1;
          } else {
            player2_score.d = player2_score.q + 1;
          }
          writer.d = writer.UPDATE_SEG;
        }
        
      writer.UPDATE_SEG:
        update_display = 1;
        writer.d = writer.IDLE;
      
      writer.INIT_BOMB:
        writer.d = writer.ERASE;
        if(random_generator.q == 6b0 || random_generator.q == 6b111111) {
          writer.d = writer.INIT_BOMB;
        } else {
          holder.d[random_generator.q[5:3]][random_generator.q[2:0]] = b11; // Bomb
          ram.write_en = b1;
          ram.waddr = random_generator.q;
          ram.write_data = BOMB_COLOR;
        }
        
      writer.IDLE:
        ram.raddr = address;
        out_encoding = ram.read_data;
        debug_data = 0; // for debugging
        writer.d = writer.IDLE; // remain in state
        if (update_flag.q){
          update_flag.d = 0;
          writer.d = writer.ERASE;
          if(bomb_set.q == 0) { //Generate Bomb
            writer.d = writer.INIT_BOMB;
            bomb_set.d = 1;
          }
        }
        debug_data = c{b11, update_flag.q};
    }
    
    out_counter = counter.q;
    out_player1_score = player1_score.q;
    out_player2_score = player2_score.q;
  }
}
